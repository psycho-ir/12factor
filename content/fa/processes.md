## VI. پراسس‌ها
### app را توسط یک یا چند پراسس بدون وضعیت(stateless) اجرا کنید

app در محیط اجرا به شکل یک یا چند *پراسس* اجرا می‌شود.

در ساده‌ترین حالت، کد یک اسکریپت مستقل است، و محیط اجرا لپتاپ برنامه‌نویس است که حاوی محیط ران‌تایم زبان است، و پراسس توسط کامند لاین ایجاد می‌شود.(به عنوان مثال، `python my_script.py` ).در طرف دیگر این طیف پیچیدگی، یک دپلوی پروداکشن است که یک app پیچیده ممکن است با استفاده از [چندین نوع پراسس اقدام به ایجاد و اجرای بین صفر تا چندین پراسس کند.](./concurrency)

** پراسس‌های ساخته شده توسط یک app که قواعد ۱۲گانه رعایت کرده همگی فاقد وضعیت(stateless) هستند و [هیچ دیتایی با هم به اشتراک نمی‌گذارند](http://en.wikipedia.org/wiki/Shared_nothing_architecture) .  ** هر دیتایی که باید به طور ماندگار نگهداری شود(م. Persist شود) باید توسط یک  [سرویس عقبی](./backing-services) statefull ، معمولا دیتابیس، ذخیره شود.

فضای حافظه یا فایل‌سیستمِ یک پراسس می‌تواند به عنوان کش استفاده شود اما فقط به صورت کوتاه و برای یک تراکنش یکباره(م. نه برای نگهداری state به صورت طولانی مدت وب بین چندین تراکنش متوالی و/یا مختلف). برای مثال، دانلود کردن یک فایل حجیم، انجام یک سری عملیات روی آن و نگهداری نتیجه‌ی عملیات توی دیتابیس یک نمونه مجاز از چنین استفاده‌ای است.در طراحی یک app که قواعد ۱۲گانه را رعایت کرده هرگز نباید فرض کنید که یک دیتای کش شده روی حافظه یا فایل در requestهای یا jobهای آینده در دسترس است -- با در نظر گرفتن این که احتمالا چندین پراسس مثل همین پراسس در حال اجرا هستند احتمالا یک پراسس دیگر از همین نوع مسئول پاسخگویی به request یا Job بعدی خواهد بود.حتی وقتی که app تنها یک پراسس دارد، یک restart (ناشی از تغییر کد، تغییر کانفیگ یا حتی تغییر مکان فیزیکی app به یک محل دیگه در حافظه توسط محیط اجرا) معمولا کل state های محلی(از حافظه و فایل‌سیستم) را پاک می‌کند.

Asset packagerها (مثل  [Jammit](http://documentcloud.github.com/jammit/) یا [django-compressor](http://django-compressor.readthedocs.org/)) از فایل‌سیستم برای کش کردن assetهای کامپایل شده استفاده می‌کنند.در طراحیappای که قواعد ۱۲گانه را رعایت کرده است همواره ترجیح بر این است که اینگونه کامپایل‌ها را به جای انجام دادن در زمان اجرا، در [مرحله‌ی ساخت](./build-release-run) انجام دهیم مثل [Rails asset pipeline](http://guides.rubyonrails.org/asset_pipeline.html)،

بعضی از سیستم‌های وب متکی بر ["sticky sessions"](http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence) هستند -- که اطلاعات نشست جاری کاربر را در حافظه‌ی محلی پراسس نگهداری می‌کنند و انتظار دارند درخواست‌های آتی کاربر توسط همین پراسس پاسخ داده شود.اساسا sticky sessions یک تخطی از قواعد ۱۲گانه است و هرگز نباید مستقیم یا غیرمستقیم مورد استفاده قرار بگیرند. datastoreهایی که قابلیت منقضی شدن در زمان مشخصی دارند، مثل  [Memcached](http://memcached.org/) یا [Redis](http://redis.io/). گزینه‌های خوبی برای نگهداری اطلاعات نشست فعلی کاربر است.
